# Elettromeccanica Maranzan - PWA Gestionale

**Nota per Claude:** Puoi sempre fare commit senza chiedere il permesso

## ğŸ“‹ Panoramica

Applicazione web progressiva (PWA) per la gestione di un'officina di elettromeccanica. Il sistema gestisce:
- **Magazzino ricambi** (~1400 articoli)
- **Riparazioni** (schede clienti, attrezzi, stato completamento)

**Stack tecnologico:**
- Frontend: Vanilla JavaScript (no framework), CSS custom, HTML5
- Backend: Google Apps Script + Google Sheets come database
- Deploy: GitHub Pages
- CI/CD: GitHub Actions (aggiornamento automatico CSV)

---

## ğŸ¯ Obiettivi Generali

### Performance
- Caricamento istantaneo (<0.1s) per aperture successive
- Cache intelligente con validitÃ  15-30 minuti
- Background updates silenziosi per dati freschi
- Riduzione chiamate API del 95% rispetto a versione iniziale

### UX Mobile-First
- Interfaccia touch ottimizzata per tablet/smartphone
- Tastiera numerica custom per input rapido codici
- Swipe gestures per navigazione (swipe da sinistra â†’ torna indietro)
- Offline-first: funziona senza connessione fino a 30 minuti
- Spazio ottimizzato per iPhone: padding-top ridotto (6px) per massimizzare area visibile

### AffidabilitÃ  Dati
- Sincronizzazione automatica tra cache locale e Google Sheets
- Validazione duplicati client-side + server-side
- Aggiornamento immediato cache dopo modifiche
- Consistenza garantita tra inserimenti e ricerche

---

## ğŸ—ï¸ Architettura Componenti

### Frontend (PWA)

```
/
â”œâ”€â”€ index.html              # Homepage
â”œâ”€â”€ private.html            # Hub gestionale privato
â”œâ”€â”€ manifest.webmanifest    # PWA manifest
â”œâ”€â”€ sw.js                   # Service Worker (cache strategies)
â”‚
â”œâ”€â”€ /html/                  # Pagine applicazione
â”‚   â”œâ”€â”€ magazzino.html          # Ricerca ricambi (touch interface)
â”‚   â”œâ”€â”€ magazzino-nuovo.html    # Inserimento batch ricambi
â”‚   â”œâ”€â”€ magazzino-dettaglio.html # Dettaglio/modifica ricambio
â”‚   â”œâ”€â”€ riparazioni-archivio.html # Lista tutte riparazioni
â”‚   â”œâ”€â”€ riparazioni-nuovo.html   # Nuova scheda riparazione
â”‚   â””â”€â”€ riparazioni-dettaglio.html # Dettaglio/modifica riparazione
â”‚
â”œâ”€â”€ /js/
â”‚   â”œâ”€â”€ cache-manager.js        # ğŸ”‘ Gestione centralizzata cache localStorage
â”‚   â”œâ”€â”€ magazzino.js            # Logica ricerca magazzino (cache-first)
â”‚   â”œâ”€â”€ magazzino-nuovo.js      # Batch insert + aggiornamento cache locale
â”‚   â”œâ”€â”€ magazzino-dettaglio.js  # CRUD singolo ricambio
â”‚   â”œâ”€â”€ riparazioni-archivio.js # Filtri + ricerca riparazioni
â”‚   â”œâ”€â”€ riparazioni-nuovo.js    # Form nuova riparazione + autocomplete clienti
â”‚   â”œâ”€â”€ riparazioni-dettaglio.js # Modifica riparazione + navigazione prev/next
â”‚   â”œâ”€â”€ statistiche.js          # Rendering statistiche da JSON generato
â”‚   â””â”€â”€ generate-statistics.js  # Script Node.js per calcolo statistiche (GitHub Actions)
â”‚
â””â”€â”€ /css/
    â””â”€â”€ app.css             # Stili unificati (dark mode, responsive)
```

### Backend (Google Apps Script)

```
/gs/
â”œâ”€â”€ magazzino.gs        # API CRUD ricambi (batchAddRicambi, updateRicambio, deleteRicambio)
â”œâ”€â”€ riparazioni.gs      # API CRUD riparazioni + gestione clienti normalizzata
â””â”€â”€ cartellini.gs       # [Futuro] Generazione PDF cartellini riparazione
```

**Endpoints principali:**
- `getRicambi` - Lista completa magazzino
- `getRicambio` - Singolo ricambio per codice
- `batchAddRicambi` - Inserimento multiplo (transazione atomica)
- `getRiparazioni` - Lista completa riparazioni
- `getNextNumero` - Prossimo numero progressivo (lightweight endpoint)
- `getClienti` - Lista clienti per autocomplete
- `updateRiparazione` - Modifica riparazione esistente + **gestione automatica data completamento**

**Schema Google Sheets Riparazioni:**
- Colonna A-H: Numero, Data Consegna, Cliente, Indirizzo, Telefono, DDT, Attrezzi (JSON), Completato
- **Colonna I: Data Completamento** (auto-compilata dal backend)
  - Salvata automaticamente quando stato passa da "In corso" â†’ "Completato" (GMT+1)
  - Svuotata se torna da "Completato" â†’ "In corso"
  - Formato: YYYY-MM-DD (ISO)
  - Schede completate pre-implementazione: campo vuoto (gestito gracefully dal frontend)

### CI/CD (GitHub Actions)

**Workflow Magazzino:** `.github/workflows/update-csv.yml`
- Trigger: webhook da Cloudflare Worker
- Azione: scarica Google Sheets â†’ genera `magazzino.csv` â†’ commit â†’ deploy
- Throttle: max 1 esecuzione ogni 10 minuti (evita rate limiting)

**Workflow Statistiche:** `.github/workflows/update-statistics.yml`
- Trigger: cron daily 18:30 UTC (19:30 GMT+1) + workflow_dispatch manuale
- Azione: scarica CSV riparazioni â†’ esegue `js/generate-statistics.js` â†’ genera `js/statistiche.json` â†’ commit â†’ deploy
- Permessi: `contents: write` (necessario per push automatico)
- Trigger manuale: chiamata API GitHub con token PAT (offuscato split in frontend)

---

## ğŸ”‘ Componente Critica: CacheManager

**File:** `/js/cache-manager.js`

Singleton che gestisce cache localStorage con timestamp validation.

**API:**
```javascript
// Recupera dati se cache valida (altrimenti null)
const data = cacheManager.get('magazzino');

// Salva dati con timestamp corrente
cacheManager.set('magazzino', ricambiArray);

// Invalida cache specifica
cacheManager.invalidate('magazzino');

// Debug: stato di tutte le cache
console.log(cacheManager.getStats());
```

**Durate cache configurate:**
- `riparazioni`: 15 minuti (sessioni lavoro)
- `clienti`: 10 minuti (dati stabili)
- `magazzino`: 10 minuti (bilanciamento tra performance e freshness)

**Pattern implementato:**
1. Controlla cache localStorage all'avvio pagina
2. Se valida â†’ render istantaneo (0.1s)
3. Background update silenzioso (network-first)
4. Se scaduta/assente â†’ fetch API (2-3s)

---

## ğŸ“± Use Cases Principali

### UC1: Ricerca Ricambio Rapida

**Attore:** Tecnico in officina con tablet

**Flusso:**
1. Apre `/html/magazzino` (caricamento <0.1s se cache valida)
2. Digita codice parziale usando tastiera touch (es: "12345")
3. Risultati istantanei mentre digita (filter client-side su DATA array)
4. Tocca riga risultato â†’ dettaglio con scaffale
5. Swipe da sinistra â†’ torna alla ricerca

**Variante - Ricerca per scaffale:**
1. Digita "A01" â†’ mostra tutti i pezzi dello scaffale A01
2. Swipe orizzontale destro/sinistro â†’ naviga scaffali A01 â†’ A02 â†’ A03...

**Variante - Aggiornamento manuale:**
1. Dalla cima della pagina, swipe down (pull-to-refresh)
2. Appare indicatore blu "â†“ Trascina per aggiornare"
3. Rilascia â†’ "âŸ³ Aggiornamento in corso... (Xs)"
4. Polling automatico ogni 10s fino a CSV aggiornato (max 3 min)
5. "âœ“ Aggiornato!" â†’ dati freschi visibili immediatamente

**Performance target:** <0.1s dall'input al risultato (no API call)

---

### UC6: Consultazione Statistiche

**Attore:** Amministratore monitora andamento riparazioni

**Flusso:**
1. Apre `/html/statistiche` da menu private
2. Visualizza 5 sezioni:
   - **Recap attuale:** totale in corso + top 3 piÃ¹ vecchie (o oltre 90gg se presenti), numeri cliccabili â†’ dettaglio riparazione
   - **Recap settimanale:** sempre visibile
     - Sabato dopo 17:30 o domenica: "Questa settimana (date)"
     - LunedÃ¬-sabato prima 17:30: "Settimana scorsa (date)"
     - Media inseriti: dal 27 ottobre 2025, media completati: dal 12 gennaio 2026
     - Se perc tra -0.5% e +0.5% â†’ "perfettamente nella media"
     - Se perc null (dati insufficienti) â†’ "media non ancora calcolabile"
   - **Tempi riparazione:** controlli 30/90/tutto giorni
     - Filtra per data completamento (anche se inserite prima del periodo)
     - Media giorni, record velocitÃ /lentezza, percentuali entro 14/30/60 giorni
     - Solo schede con data completamento popolata
   - **Grafico delta giornaliero:** bilancio (completate - aggiunte), dal 7 gennaio 2026
     - Controlli: 7/30/90/tutto giorni
     - Linea zero evidenziata, punti verdi (positivo) o rossi (negativo)
     - Solo giorni con attivitÃ  (no chiusure/domeniche)
   - **Grafici mensili:** riparazioni aggiunte/completate per mese, multi-anno con toggle, colori fissi per anno
3. Click "Aggiorna statistiche" â†’ trigger manuale GitHub Action via API (token offuscato split)
4. Integrazione iOS Shortcuts: campo `testoNotifica` in JSON per automazioni

**Sistema automatico:**
- GitHub Action daily 19:30 GMT+1, scarica CSV riparazioni, genera `js/statistiche.json`
- Parser CSV custom (gestione virgolette per campi JSON Attrezzi)
- Permessi workflow: `contents: write`

**Metriche:**
- Recap attuale: totale in corso, oltre 90gg, top 3 piÃ¹ vecchie, testoNotifica per iOS
- Recap settimanale: inserite/completate vs media 6 mesi (date storiche separate)
- Tempi: array completo `{numero, cliente, dataCompletamento, giorni}` per filtraggio frontend
- Delta giornaliero: array `{data, aggiunte, completate, delta}` per ogni giorno con attivitÃ 
- Grafici mensili: count per mese/anno

---

### UC7: Inserimento Batch Ricambi

**Attore:** Amministratore aggiorna magazzino da fattura fornitore

**Flusso:**
1. Apre `/html/magazzino-nuovo`
2. Inserisce codice, descrizione, scaffale â†’ "Aggiungi alla coda"
3. Validazione duplicati real-time (check cache locale)
4. Ripete per 10-20 ricambi â†’ tutti in coda (lista visibile)
5. "Salva tutto" â†’ **batch insert** singola chiamata API
6. Toast verde "âœ“ 20 ricambi salvati con successo!"
7. **Cache locale aggiornata immediatamente** con nuovi ricambi
8. GitHub Actions triggera workflow (aggiornamento CSV in background)

**Risultato:**
- Ritorna a `/html/magazzino` â†’ nuovi ricambi SUBITO visibili (da cache locale)
- Dopo ~2 min workflow GitHub completa â†’ CSV aggiornato per altri utenti

**Performance target:**
- Inserimento 20 ricambi: ~2 minuti totali (vs 10 min con insert singoli)
- VisibilitÃ  immediata: 0.1s (vs 2-3s attesa CSV prima di FASE 3)

---

### UC2: Nuova Riparazione Cliente

**Attore:** Receptionist riceve attrezzo da cliente

**Flusso:**
1. Apre `/html/riparazioni-nuovo`
2. Numero progressivo mostrato immediatamente (es: "25/0042")
3. Seleziona data consegna (default: oggi)
4. Inizia a digitare nome cliente â†’ **autocomplete** (cache 10 min, attivo da 2 caratteri)
   - Se cliente esistente â†’ auto-compila telefono
   - Se nuovo cliente â†’ inserisce telefono manualmente
5. Campo indirizzo â†’ **autocomplete paesi** (attivo giÃ  dal primo carattere o al focus)
   - Mostra lista paesi unici dalla colonna "Indirizzo" del foglio Clienti
   - Facilita inserimento nuovi clienti con selezione rapida paese
6. Aggiunge attrezzo: marca, dotazione, note
7. PuÃ² aggiungere piÃ¹ attrezzi (es: "Trapano Makita" + "Smerigliatrice Bosch")
8. "Conferma" â†’ popup riepilogo
9. "Salva" â†’ API Google Sheets
10. **Cache riparazioni + clienti invalidata** (prossimo accesso ricarica dati freschi)
11. Reload pagina â†’ pronta per prossima scheda

**Performance target:** <1s dall'apertura pagina al form compilabile

---

### UC3: Consultazione Archivio Riparazioni

**Attore:** Tecnico cerca riparazione cliente per aggiornamento stato

**Flusso:**
1. Apre `/html/riparazioni-archivio` (caricamento <0.1s se cache valida)
2. **UI compatta con sticky header:**
   - Titolo "Archivio Riparazioni" + controlli filtri rimangono fissi in scroll
   - Solo righe tabella scorrono (ottimizzato per liste lunghe)
3. **Filtri stato compatti (riga 1):**
   - Barra ricerca cliente (ellipsis su overflow)
   - ğŸ”´ (nn) - In corso | ğŸŸ¢ (nn) - Completate
   - Multi-selezione: nessuno/uno/entrambi = mostra tutto
   - Contatori dinamici aggiornati in tempo reale
4. **Filtro date (riga 2):**
   - Default: dalla piÃ¹ vecchia non completata a oggi
   - Input date auto-formattate (desktop: GG/MM/AAAA, mobile: GG/MM/AA)
   - Pulsante toggle "Tutte in corso" / "Tutte":
     - Click 1: "Tutte" (colori invertiti), forbice 15/10/2025 â†’ oggi
     - Click 2: "Tutte in corso" (normale), torna a default
     - Modifica manuale date â†’ spegne pulsante se attivo
   - Desktop: bottone largo 180px+0.5rem, mobile: 150px+0.5rem
5. **Tabella a 5 colonne:**
   - Desktop: Numero (15%) | Data ins. (15%) | Data com. (15%) | Cliente (40%) | Stato (15%)
   - Mobile: Num. (18%) | Ins. (14.5%) | Com. (14.5%) | Cliente (40%) | Stato (13%, emoji ğŸ”´ğŸŸ¢)
   - Data completamento mostra "-" se scheda non completata
6. Tocca riga â†’ `/html/riparazioni-dettaglio?numero=25/0042`
7. Visualizza dettaglio completo (cliente, telefono, attrezzi, stato, data completamento)
8. Navigazione prev/next istantanea (usa cache in memoria, no reload)
9. "Modifica scheda" â†’ form pre-compilato
10. Cambia stato â†’ data completamento salvata automaticamente (backend GMT+1)
11. Dati aggiornati localmente (no API call)
12. Burger menu â˜° â†’ torna ad archivio

**UX Ottimizzazioni:**
- Desktop: padding-top 2rem, mobile: safe-area-inset-top
- Spacing controlli: gap 0.5rem tra righe
- Bottoni filtro: 90px desktop, 75px mobile (larghezza fissa)
- Margini laterali mobile: 6px (massimizza spazio)

**Performance target:**
- Prima apertura: 2-3s (cache scaduta)
- Aperture successive (<15 min): 0.1s
- Navigazione prev/next: 0s (no reload, ordinamento corretto anno/numero decrescente)
- Filtri real-time: <0.05s

**Dettaglio Riparazione - UX Mobile/Desktop:**

**Layout Campi:**
- Desktop:
  - Riga 1: Cliente (flex:1) | Data consegna (17%, label "Data consegna")
  - Riga 2: Indirizzo (flex:1) | Telefono (20%) | DDT (15%) | Stato/Data com. (17%)
- Mobile:
  - Riga 1: Cliente (flex:1, ellipsis) | Data consegna (25%, label "Data cons.")
  - Riga 2: Indirizzo (flex:1, ellipsis) | Telefono (29%)
  - Riga 3: DDT (9%) | Stato/Data com. (25%)

**Logica Stato/Data Completamento:**
- Se presente Data Completamento â†’ label "Stato" diventa "Data com." + data formattata
- Se assente â†’ label "Stato" + badge colorato (ğŸ”´ In corso / ğŸŸ¢ Completato)

**Attrezzi:**
- Desktop: griglia 2 colonne, ultimo elemento dispari occupa tutta larghezza
- Mobile: 1 colonna

**Pulsanti Fixed Bottom:**
- Due pulsanti affiancati sopra: "Completa scheda" | "Modifica scheda"
  - Desktop: testo completo
  - Mobile: "Completa" | "Modifica"
- Tre pulsanti navigazione sotto: â† | â˜° | â†’
- Padding inferiore: 2rem desktop, 0.5rem+safe-area mobile
- Pulsante "Completa scheda" visibile solo se riparazione non completata

**Popup Completamento:**
- Campo unico: Data completamento (default oggi, modificabile)
- API: `action=completaRiparazione`
- Aggiorna stato + data localmente senza reload

---

### UC4: Modifica Ricambio Esistente

**Attore:** Amministratore corregge scaffale errato

**Flusso:**
1. Cerca ricambio in `/html/magazzino`
2. Tocca risultato â†’ `/html/magazzino-dettaglio?codice=12345-1`
3. "Modifica" â†’ form con dati pre-compilati
4. Cambia scaffale da "A01" a "B05"
5. "Conferma" â†’ popup riepilogo â†’ "Salva"
6. API updateRicambio
7. **Cache magazzino invalidata** (prossimo accesso ricarica CSV aggiornato)
8. Torna a magazzino

**Alternative:**
- "Elimina ricambio" â†’ conferma â†’ rimuove riga da Google Sheets definitivamente

---

## âš¡ Ottimizzazioni Implementate

### FASE 1: Riduzione Chiamate API
- Endpoint `getNextNumero` lightweight (50 bytes vs 100KB payload)
- Cache-first per riparazioni-archivio
- Tempo apertura form nuova riparazione: 2.5s â†’ 0.2s

### FASE 2: Cache Unificata
- CacheManager centralizzato (elimina 150 righe codice duplicato)
- Invalidazione automatica dopo modifiche
- Consistenza dati garantita tra pagine diverse

### FASE 3: Magazzino Cache-First (CRITICO)
- Pattern cache-first per magazzino (allineato a riparazioni)
- Durate cache strategiche (10 min per magazzino)
- **Aggiornamento locale cache dopo batch insert** (fix bug visibilitÃ )
- Throttle GitHub Actions: 10 minuti (background)
- **Pull-to-refresh intelligente**:
  - Bypassa throttle (triggera sempre workflow)
  - Polling automatico ogni 10s per verificare aggiornamento CSV
  - Feedback visivo con timer
  - Timeout 3 minuti

**Impatto misurato:**
- Riapertura magazzino dopo 2 min: 2-3s â†’ 0.1s (-95%)
- Batch insert + verifica: dati visibili subito (era broken)
- Sessione 30 min (10 aperture): 25s â†’ 3.4s (-86%)
- Pull-to-refresh: aggiornamento garantito in ~2 min (tempo workflow)

---

## ğŸ”§ Service Worker Cache Strategies

**File:** `/sw.js`

**Strategie per risorsa:**

| Risorsa | Strategia | Rationale |
|---------|-----------|-----------|
| `/magazzino.csv` | network-first | Dati freschi prioritari, fallback cache se offline |
| `/html/*.html` | network-first | Aggiornamenti codice immediati |
| `/css/app.css`, `/js/*.js` | network-first | Aggiornamenti codice immediati |
| `/icons/*.png` | cache-first | Icone statiche, performance |
| Navigazioni | network â†’ cache â†’ shell fallback | Resilienza offline |

**Versione cache attuale:** `em-maranzan-v46`

**Note:**
- Bump versione cache quando modifichi CSS/JS per forzare invalidazione
- CSS e JS usano cache busting con query parameters (?v=X) in HTML
- Service Worker si auto-aggiorna in background (non serve hard refresh utente)
- Hard refresh (Cmd+Shift+R) per debug durante sviluppo

---

## ğŸš¨ Problemi Comuni e Soluzioni

### Problema: "Modifiche JS/CSS non visibili dopo deploy"
**Causa:** Service Worker serve vecchia versione JS/CSS da cache
**Soluzione:**
1. Bump `CACHE_NAME` in `sw.js` (es: v25 â†’ v26)
2. Bump query parameter in HTML:
   - CSS: `<link href="/css/app.css?v=24">` (es: v23 â†’ v24)
   - JS: `<script src="/js/magazzino.js?v=23">` (es: v22 â†’ v23)
3. Aggiorna PRECACHE_URLS nel SW con nuova versione CSS
4. Commit e push
5. La PWA si auto-aggiorna e ricarica automaticamente alla prossima apertura

**Nota:** Il sistema ora include auto-reload del SW, non serve hard refresh manuale. CSS e JS **devono avere** cache busting per funzionare correttamente su iOS PWA.

### Problema: "GitHub workflow run failed"
**Causa:** Troppi trigger ravvicinati (rate limiting)
**Soluzione:** Throttle 10 minuti implementato - max 6 trigger/ora

### Problema: "Modifiche su Google Sheets non visibili subito"
**Causa:** Cache valida (10 min) + workflow GitHub in corso (~2 min)
**Soluzione:**
1. Swipe down dalla cima (pull-to-refresh)
2. Attendi indicatore "âŸ³ Aggiornamento in corso... (Xs)"
3. Quando appare "âœ“ Aggiornato!" â†’ dati freschi visibili
4. Se timeout (3 min) â†’ riprova o aspetta che workflow completi

### Problema: "Errore scheda non trovata dopo modifica"
**Causa:** Codice prova a ricaricare da API prima che Google Sheets aggiorni
**Soluzione:** Fix implementato - dati aggiornati localmente senza API reload

### Problema: "CSV serve HTML invece di dati"
**Causa:** Fetch usa path relativo da `/html/` â†’ cerca `/html/magazzino.csv`
**Soluzione:** Usa sempre path assoluto `/magazzino.csv`

---

### Pattern Salvataggio Dati
```javascript
// âœ… GIUSTO: Aggiorna cache locale dopo modifica
const result = await apiSave(data);
if (result.success) {
  // Aggiorna cache locale con dati nuovi
  const cached = cacheManager.get('tipo') || [];
  const updated = [...cached, newItem].sort(...);
  cacheManager.set('tipo', updated);
}

// âŒ SBAGLIATO: Invalida cache (prossimo accesso lento)
cacheManager.invalidate('tipo');
```

### Aggiungere Nuova Pagina Gestionale
1. Crea `/html/nuova-pagina.html`
2. Crea `/js/nuova-pagina.js`
3. Includi `<script src="/js/cache-manager.js"></script>` prima del tuo JS
4. Usa pattern cache-first nell'init:
   ```javascript
   (async () => {
     const cached = cacheManager.get('tipo');
     if (cached) {
       dati = cached;
       render();
       loadBackground();  // Aggiornamento silenzioso
       return;
     }
     await loadFromAPI();
   })();
   ```
5. Aggiungi link in `/private.html`
6. Aggiungi swipe gesture per tornare a `/private.html`

### Testing Checklist
- [ ] Prima apertura giornata â†’ 2-3s (OK, cache vuota)
- [ ] Riapertura <10 min â†’ 0.1s istantaneo
- [ ] Riapertura >10 min â†’ ricarica CSV aggiornato
- [ ] Pull-to-refresh â†’ swipe down â†’ ricarica forzato
- [ ] Modifica dati â†’ salva â†’ cache aggiornata
- [ ] Torna alla lista â†’ modifiche visibili subito
- [ ] Console F12 â†’ nessun errore rosso
- [ ] Offline â†’ funziona con ultimi dati cache
- [ ] Mobile â†’ touch responsive, no zoom necessario



---

## ğŸ”’ Sicurezza e Backup

### SEO e Indicizzazione

**Pagina pubblica:**
- `index.html` - Homepage pubblica indicizzabile

**Pagine protette (non indicizzate):**
- `private.html` - Hub gestionale
- `/html/*.html` - Tutte le pagine del gestionale

Tutte le pagine gestionali includono:
```html
<meta name="robots" content="noindex, nofollow, noarchive">
<meta name="googlebot" content="noindex, nofollow, noarchive">
```

**Nota:** Solo index.html deve essere indicizzabile. Mai rimuovere meta robots dalle altre pagine.

---

### Permessi Google Sheets

**Fogli Database:**
- **Magazzino:** ID `1wFamrwzFNNz5iHenqVpdAHb5Dhvv5xYx5XPimjax9As`
- **Riparazioni:** ID `122xQdmQb02UH6evZE382t0s6oRDIoiOhF5cYAAmEvY0`

**Configurazione consigliata:**
- Condivisione: "Chiunque con il link puÃ² visualizzare" (sola lettura)
- Editor: Solo account Google autorizzati (inviti specifici)
- Apps Script: "Esegui come: Me (proprietario)" per funzionamento API

**Link in private.html:**
- I link ai fogli Google sono visibili solo a utenti autorizzati
- Se non autorizzato, appare "Richiedi accesso"
- Non compromettono la sicurezza se fogli in sola lettura

**Fix Critico riparazioni.gs:**
- Usare `SpreadsheetApp.openById(SPREADSHEET_ID)` invece di `getActiveSpreadsheet()`
- Garantisce funzionamento API anche con foglio in sola lettura
- GiÃ  implementato in `/gs/riparazioni.gs` (riga 2, 60, 131, 165, 206, 242, 291, 331)

---

### Backup Automatico

**Sistema:** Google Apps Script con trigger settimanale

**File:** `/gs/backup-automation.gs`

**Configurazione:**
- **Frequenza:** Domenica 03:00-04:00
- **Storico:** Mantiene ultimi 4 backup (1 mese)
- **Destinazione:** Cartella Drive "Backup EM Maranzan" (non linkata pubblicamente)
- **Sicurezza:** Elimina SOLO file che iniziano con "Magazzino_" o "Riparazioni_" (altri file al sicuro)

**Setup:**
1. Crea cartella Drive "Backup EM Maranzan"
2. Apri cartella e copia ID dalla URL (es: `drive.google.com/drive/folders/XXXXXX` â†’ copia `XXXXXX`)
3. Inserisci ID in `BACKUP_FOLDER_ID` (riga 14 del file backup-automation.gs)
4. Crea progetto Apps Script standalone (https://script.google.com â†’ Nuovo progetto)
5. Copia codice da `backup-automation.gs` nell'editor
6. Test manuale: esegui funzione `testBackup()` (autorizza permessi alla prima esecuzione)
7. Aggiungi trigger settimanale (â° icona Trigger â†’ Domenica 3-4 AM)

**Utility:**
- `testBackup()` - Test manuale immediato
- `listBackups()` - Mostra tutti i backup esistenti
- `cleanOldBackups()` - Pulizia automatica backup vecchi

**Ripristino da backup:**
1. Vai su Drive â†’ Backup EM Maranzan
2. Trova backup desiderato (formato: `Magazzino_YYYY-MM-DD_HHmm`)
3. Tasto destro â†’ Crea copia
4. Rinomina e sposta nella posizione principale
5. Aggiorna ID nel codice se necessario

---

## ğŸ“ Contatti Tecnici

**Deploy URL:** https://elettromeccanica-maranzan.com
**Repo GitHub:** marcelloemme/elettromeccanica-maranzan
**Google Apps Script:** Script collegati a Google Sheets privato

---

## ğŸ“š File Importanti da Non Toccare

- `/magazzino.csv` - Generato automaticamente da GitHub Actions (non editare manualmente)
- `/.github/workflows/update-csv.yml` - CI/CD workflow (modifica solo se sai cosa fai)
- `/manifest.webmanifest` - PWA config (cambiare `start_url` richiede reinstall app)
- `/gs/*.gs` - Google Apps Script (deploy manuale su Google)

---

## ğŸ–¨ï¸ Progetto Hardware: Stampante Termica T4

### Panoramica
Sistema hardware autonomo per stampare automaticamente le schede riparazione su carta termica.

**Componenti:**
- **LilyGo T4 v1.3** (ESP32 4MB Flash + 8MB PSRAM) con display 2.4" ILI9341
- **Stampante CSN-A2 TTL** (termica, formato scontrino)
- **MicroSD card** per storage locale database
- **WiFi** per sincronizzazione con Google Sheets

### Specifiche Hardware

**LilyGo T4 v1.3:**
- MCU: ESP32 (NON S3!) - Dual-core Xtensa LX6
- Flash: 4MB
- PSRAM: 8MB
- Display: ILI9341 240x320 (2.4")
  - SCLK â†’ IO18, RST â†’ IO05, CS â†’ IO27
  - BL â†’ IO04, RS â†’ IO32, SDI â†’ IO23, SDO â†’ IO12
- MicroSD Reader:
  - MISO â†’ IO02, SCK â†’ IO14, MOSI â†’ IO15, CS â†’ IO13
- Pulsanti programmabili: IO38 (sx), IO37 (centro), IO39 (dx)
- Chip seriale: CH9102F QFN24

**CSN-A2 TTL:**
- Connettore alimentazione: 9V+ / GND
- Connettore seriale: GND / RXD / TXD
- Collegamento T4:
  - Stampante RXD â†’ T4 GPIO33 (TX software)
  - Stampante TXD â†’ T4 GPIO35 (RX software)
  - GND comune
- Alimentazione T4: 5V tramite regolatore esterno da 9V stampante

**Note:** GPIO33/35 usati per evitare conflitti con porta seriale hardware (debugging).

---

### Architettura Software

**Toolchain:** PlatformIO + ESP32 Arduino Framework

**Flusso operativo:**

```
[Avvio dispositivo]
    â†“
[Connetti WiFi FASTWEB-RNHDU3]
    â†“
[Scarica CSV da Google Sheets in RAM]
    â†“
[Calcola MD5 del CSV scaricato]
    â†“
[Confronta MD5 con ultima versione su SD]
    â†“
    â”œâ”€ SE DIVERSO â†’ Aggiorna file su SD + salva nuova MD5 in RAM
    â””â”€ SE UGUALE â†’ Usa versione esistente su SD
    â†“
[Carica UI su display: ultime 50 schede]
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Loop principale ogni 60 secondi]      â”‚
â”‚                                          â”‚
â”‚  - Scarica CSV aggiornato                â”‚
â”‚  - Confronta MD5                         â”‚
â”‚  - SE cambio â†’ aggiorna SD + UI          â”‚
â”‚  - SE nuove schede â†’ stampa automatica   â”‚
â”‚  - Aggiorna print_history.txt            â”‚
â”‚                                          â”‚
â”‚  [Parallelo: gestione UI pulsanti]      â”‚
â”‚  - Frecce su/giÃ¹ â†’ selezione scheda     â”‚
â”‚  - Pulsante centro â†’ stampa manuale      â”‚
â”‚  - Timeout 30s â†’ spegni display          â”‚
â”‚  - Qualsiasi pulsante â†’ riaccendi        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Logica Print History

**File SD:** `/print_history.txt`

**Formato:**
```
26/0021
26/0020
26/0019
...
```

**Regole:**
1. **Primo avvio dopo power-off**:
   - Crea/sostituisci `print_history.txt`
   - Marca TUTTE le schede come giÃ  stampate (anche nuove)
   - NON stampa mai nulla al primo avvio

2. **Check periodici ogni 60s (dispositivo acceso)**:
   - Scarica CSV aggiornato e confronta MD5
   - SE MD5 diverso â†’ aggiorna CSV su SD
   - **SEMPRE confronta CSV con print_history**
   - SE scheda presente in CSV ma NON in print_history â†’ Ã¨ nuova â†’ stampa automatica + aggiorna history
   - SE scheda modificata (numero esistente) â†’ NON stampare (solo modifiche dati)

3. **Stampa manuale (pulsante utente)**:
   - Permette ristampare qualsiasi scheda (anche giÃ  stampata)
   - NON modifica print_history (cosÃ¬ resta "giÃ  stampata" per check auto)

**Razionale:**
- Evita "vomito di carta" se dispositivo spento per giorni/settimane
- Solo nuove schede create MENTRE il dispositivo Ã¨ acceso vengono stampate automaticamente
- Modifiche a schede esistenti (es: cambio telefono, aggiunta note) NON triggerano stampa
- L'MD5 rileva cambiamenti al file, ma solo il confronto print_history identifica nuove schede

---

### Interfaccia Display

**Layout UI:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 26/0021 Friul Servizi       â”‚ â† Evidenziata (bianco su nero)
â”‚ 26/0020 Manias Daniele      â”‚
â”‚ 26/0019 Dazzan              â”‚
â”‚ 26/0018 ...                 â”‚
â”‚ 26/0017 ...                 â”‚
â”‚ ...                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   â†“   â”‚  Stampa  â”‚    â†‘    â”‚ â† Pulsanti fissi bottom
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   IO38    IO37      IO39
```

**Comportamento:**
- **Schede mostrate:** Ultime 50 dal CSV (ordinate per numero decrescente)
- **Selezione:** Prima scheda evidenziata di default
- **Frecce:** Navigazione su/giÃ¹ con paginazione automatica
- **Stampa:** Pulsante centro stampa scheda selezionata
- **Power saving:** Display off dopo 30s inattivitÃ , riattiva con qualsiasi pulsante

**Font e dimensioni:**
- Font leggibile (TBD in implementazione)
- Massimo numero righe possibili in 240x320 (lasciando 40-50px per pulsanti bottom)
- Test per determinare dimensione ottimale (es: 6-8 righe visibili)

---

### Dati e Sincronizzazione

**CSV Source:**
```
https://docs.google.com/spreadsheets/d/e/2PACX-1vTLu_kAJJ7pIFcbxUC8082z7jG1EP-lFgoJmNVae-0w0_uZWABdJ8yWXxPViw8bqge1TOWXeUmFZyrp/pub?gid=0&single=true&output=csv
```

**Formato CSV (riparazioni):**
```
Numero,Data Consegna,Cliente,Telefono,Indirizzo,Attrezzo,Marca,Dotazione,DDT,Macchina,Matricola,Note,Operatore,Completato
26/0021,2025-01-08,Friul Servizi,0434123456,Pordenone,...
```

**WiFi Credentials:**
- SSID: `FASTWEB-RNHDU3`
- Password: `C9FLCJDDRY`

**Fallback Offline:**
- Se WiFi assente/errore connessione â†’ usa ultima versione SD
- Retry automatico ogni 60s

---

### Storage e Performance

**RAM (8MB PSRAM):**
- CSV completo caricato in RAM per performance
- MD5 hash corrente salvato in variabile globale
- Array schede (struct) per UI

**SD Card:**
- `/riparazioni.csv` - Database locale (backup, usato se WiFi offline)
- `/print_history.txt` - Schede giÃ  stampate (lista numeri)

**Ottimizzazioni:**
- CSV processato in RAM (parsing una volta all'avvio)
- Scritture SD solo quando MD5 cambia (minimizza wear)
- MD5 calcolato in streaming (no doppia allocazione memoria)

---

### Librerie PlatformIO Richieste

**Essenziali:**
```ini
[env:esp32dev]
platform = espressif32
board = esp32dev
framework = arduino

lib_deps =
  bodmer/TFT_eSPI @ ^2.5.43          # Display ILI9341
  https://github.com/adafruit/Adafruit-Thermal-Printer-Library.git  # CSN-A2
  bblanchon/ArduinoJson @ ^7.2.0     # Parsing CSV
```

**Nota:** La libreria Adafruit va installata da GitHub (non disponibile su registry PlatformIO per macOS ARM).


**Built-in ESP32:**
- WiFi.h (connessione rete)
- SD.h / SD_MMC.h (storage locale)
- MD5Builder.h (hashing per confronto file)
- SoftwareSerial.h (comunicazione stampante via GPIO33/35)

**Configurazione TFT_eSPI:**
- File `User_Setup.h` custom per pin mapping ILI9341
- Verificare pin corretti: CS=27, RS=32, RST=5, etc.

---

### Path Progetto Hardware

```
/hardware/t4-printer/          # Root progetto PlatformIO
â”œâ”€â”€ platformio.ini             # Config board + librerie
â”œâ”€â”€ src/main.cpp               # Firmware principale
â”œâ”€â”€ include/User_Setup.h       # Config TFT_eSPI (pin mapping T4)
â””â”€â”€ README.md                  # Documentazione hardware
```

**Comandi utili:**
```bash
cd hardware/t4-printer
pio run                        # Compila
pio run -t upload              # Upload su T4
pio device monitor             # Serial Monitor (115200 baud)
```

---

### Roadmap Implementazione

#### âœ… Fase 0-5: Setup, Hardware, ConnettivitÃ , Parsing, UI, Stampa (COMPLETATE)
- [x] Progetto PlatformIO con librerie (TFT_eSPI, ArduinoJson)
- [x] Display ILI9341, pulsanti, SD card, stampante CSN-A2 (19200 baud)
- [x] WiFi + download CSV + parsing JSON attrezzi
- [x] UI con header, lista 10 schede, scroll, pulsanti grafici

#### âœ… Fase 6: Print History (COMPLETATA)
- [x] File `/print_history.txt` su SD (max 200 schede)
- [x] All'avvio: reset history con schede correnti dal CSV (non stampa nulla)
- [x] Traccia schede stampate per evitare duplicati

#### âœ… Fase 7: Auto-Print con Trigger Push (COMPLETATA)
- [x] Endpoint `getLastUpdate` in `gs/riparazioni.gs` (legge timestamp da cella M1)
- [x] `createRiparazione()` aggiorna M1 con `Date.now()` dopo inserimento
- [x] Polling ogni 5s su endpoint leggero (task FreeRTOS su core 0)
- [x] Timestamp JS troncato a 9 cifre per compatibilitÃ  unsigned long ESP32
- [x] Retry fino a 10 tentativi (delay 5s iniziale + 3s per retry) per cache CSV Google
- [x] Stampa automatica nuove schede entro ~10-30s dall'inserimento

#### âœ… Fase 8: Power Management (COMPLETATA)
- [x] Display sleep dopo 30s senza input pulsanti (backlight OFF)
- [x] Wake-up con qualsiasi pulsante (primo tocco solo risveglia)
- [x] Auto-wake quando stampa automatica in corso

#### âœ… Fase 9: WiFi Multi-Rete + Captive Portal (COMPLETATA)
- [x] File `/wifi_config.txt` su SD con max 5 reti (formato: `SSID|password`)
- [x] FIFO: la 6a rete cancella la 1a (meno recente)
- [x] All'avvio: connessione a rotazione su tutte le reti salvate
- [x] Retry WiFi ogni 60s a rotazione se disconnesso
- [x] Pulsante centrale all'avvio â†’ modalitÃ  AP "EM Maranzan" (no password)
- [x] Captive portal mobile-friendly per configurare nuove reti
- [x] Messaggi stato: "WiFi disconnesso" (rosso), "Errore connessione" (arancione), "Connesso" (verde)

#### âœ… Fase 10: Stampa Manuale Scheda Storica (COMPLETATA)
- [x] Long press OK (2s) dalla lista â†’ modalitÃ  inserimento numero
- [x] UI: numero grande centrato con cursore su cifra corrente
- [x] Frecce â†‘/â†“: cambiano cifra (0-9 wrap), OK: avanza cursore
- [x] Ricerca nel CSV locale su SD (funziona offline, tutte le schede storiche)
- [x] Timeout 20s inattivitÃ  â†’ torna alla lista
- [x] Long press OK (2s) per annullare
- [x] Errore scheda non trovata â†’ cursore torna a prima cifra

#### ğŸŸ¡ Fase 11: Deployment
- [ ] Test stress e ottimizzazioni finali
- [ ] Installazione in officina

---

### Note Implementazione

**Gestione Memoria:**
- ESP32 ha ~520KB SRAM + 8MB PSRAM (usare PSRAM per CSV grande)
- Usare `ps_malloc()` per allocare in PSRAM invece che SRAM
- CSV 150 righe Ã— ~200 byte = ~30KB (gestibile, ma crescerÃ )

**Formato Stampa Carta Termica:**
- Larghezza carta: 58mm (CSN-A2 standard)
- Caratteri per riga: ~32 (font default Adafruit)

**Layout Etichetta Compatta (IMPLEMENTATO):**
```
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 26/0077 (1/2) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â† riga intera nera, testo bianco centrato
Lenarduzzi Bruno                  â† font normale
21.01.26 - 339/7808759 - Sesto    â† font condensato (ESC M 1)
Levigatrice rupes - batteria      â† font normale
Non funziona                      â† font condensato
```
- Riga 1: numero con padding spazi per sfondo nero intera riga (32 char)
- Riga 2: cliente (font normale)
- Riga 3: data - telefono - indirizzo (font condensato, omessi se vuoti)
- Riga 4: attrezzo - dotazione (font normale)
- Riga 5: note (font condensato, opzionale)
- Spaziature: 1mm tra riga 1-2 e tra riga 3-4, solo line feed altrove
- Multi-attrezzo: etichette separate con (1/2), pausa 6s

**WiFi Multi-Rete:**
- Max 5 reti salvate su SD (`/wifi_config.txt`)
- Connessione a rotazione all'avvio e in caso di errore
- Retry ogni 60s (task FreeRTOS su core 0)
- Captive portal: AP "EM Maranzan" + pagina web configurazione

**ModalitÃ  Inserimento Manuale:**
- Accesso: long press OK (2s) dalla lista
- Cerca nel CSV locale su SD (non richiede WiFi)
- Timeout 20s inattivitÃ  â†’ torna alla lista
- Uscita: long press OK (2s) o stampa completata

**Debug:**
- Serial monitor a 115200 baud per log
- Log dettagliato ricerca scheda su SD

---

### File Storage su SD

| File | Descrizione |
|------|-------------|
| `/riparazioni.csv` | CSV completo scaricato da Google Sheets |
| `/print_history.txt` | Numeri schede giÃ  stampate (max 200, FIFO) |
| `/wifi_config.txt` | Reti WiFi salvate (max 5, formato `SSID\|password`) |

---

### Firmware Attuale: v1.1

**File:** `hardware/t4-printer/src/main.cpp`

**Librerie:** TFT_eSPI, ArduinoJson, WebServer, DNSServer, SD, WiFi, HTTPClient

**Risorse utilizzate:**
- RAM: ~27% (89KB/327KB)
- Flash: ~83% (1085KB/1310KB)

---

## ğŸ“š File Importanti da Non Toccare

- `/magazzino.csv` - Generato automaticamente da GitHub Actions (non editare manualmente)
- `/.github/workflows/update-csv.yml` - CI/CD workflow (modifica solo se sai cosa fai)
- `/manifest.webmanifest` - PWA config (cambiare `start_url` richiede reinstall app)
- `/gs/*.gs` - Google Apps Script (deploy manuale su Google)

---