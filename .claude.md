# Elettromeccanica Maranzan - PWA Gestionale

**Nota per Claude:** Puoi sempre fare commit senza chiedere il permesso

## üìã Panoramica

Applicazione web progressiva (PWA) per la gestione di un'officina di elettromeccanica. Il sistema gestisce:
- **Magazzino ricambi** (~1400 articoli)
- **Riparazioni** (schede clienti, attrezzi, stato completamento)

**Stack tecnologico:**
- Frontend: Vanilla JavaScript (no framework), CSS custom, HTML5
- Backend: Google Apps Script + Google Sheets come database
- Deploy: GitHub Pages
- CI/CD: GitHub Actions (aggiornamento automatico CSV)

---

## üéØ Obiettivi Generali

### Performance
- Caricamento istantaneo (<0.1s) per aperture successive
- Cache intelligente con validit√† 15-30 minuti
- Background updates silenziosi per dati freschi
- Riduzione chiamate API del 95% rispetto a versione iniziale

### UX Mobile-First
- Interfaccia touch ottimizzata per tablet/smartphone
- Tastiera numerica custom per input rapido codici
- Swipe gestures per navigazione (swipe da sinistra ‚Üí torna indietro)
- Offline-first: funziona senza connessione fino a 30 minuti
- Spazio ottimizzato per iPhone: padding-top ridotto (6px) per massimizzare area visibile

### Affidabilit√† Dati
- Sincronizzazione automatica tra cache locale e Google Sheets
- Validazione duplicati client-side + server-side
- Aggiornamento immediato cache dopo modifiche
- Consistenza garantita tra inserimenti e ricerche

---

## üèóÔ∏è Architettura Componenti

### Frontend (PWA)

```
/
‚îú‚îÄ‚îÄ index.html              # Homepage
‚îú‚îÄ‚îÄ private.html            # Hub gestionale privato
‚îú‚îÄ‚îÄ manifest.webmanifest    # PWA manifest
‚îú‚îÄ‚îÄ sw.js                   # Service Worker (cache strategies)
‚îÇ
‚îú‚îÄ‚îÄ /html/                  # Pagine applicazione
‚îÇ   ‚îú‚îÄ‚îÄ magazzino.html          # Ricerca ricambi (touch interface)
‚îÇ   ‚îú‚îÄ‚îÄ magazzino-nuovo.html    # Inserimento batch ricambi
‚îÇ   ‚îú‚îÄ‚îÄ magazzino-dettaglio.html # Dettaglio/modifica ricambio
‚îÇ   ‚îú‚îÄ‚îÄ riparazioni-archivio.html # Lista tutte riparazioni
‚îÇ   ‚îú‚îÄ‚îÄ riparazioni-nuovo.html   # Nuova scheda riparazione
‚îÇ   ‚îî‚îÄ‚îÄ riparazioni-dettaglio.html # Dettaglio/modifica riparazione
‚îÇ
‚îú‚îÄ‚îÄ /js/
‚îÇ   ‚îú‚îÄ‚îÄ cache-manager.js        # üîë Gestione centralizzata cache localStorage
‚îÇ   ‚îú‚îÄ‚îÄ magazzino.js            # Logica ricerca magazzino (cache-first)
‚îÇ   ‚îú‚îÄ‚îÄ magazzino-nuovo.js      # Batch insert + aggiornamento cache locale
‚îÇ   ‚îú‚îÄ‚îÄ magazzino-dettaglio.js  # CRUD singolo ricambio
‚îÇ   ‚îú‚îÄ‚îÄ riparazioni-archivio.js # Filtri + ricerca riparazioni
‚îÇ   ‚îú‚îÄ‚îÄ riparazioni-nuovo.js    # Form nuova riparazione + autocomplete clienti
‚îÇ   ‚îú‚îÄ‚îÄ riparazioni-dettaglio.js # Modifica riparazione + navigazione prev/next
‚îÇ   ‚îú‚îÄ‚îÄ statistiche.js          # Rendering statistiche da JSON generato
‚îÇ   ‚îî‚îÄ‚îÄ generate-statistics.js  # Script Node.js per calcolo statistiche (GitHub Actions)
‚îÇ
‚îî‚îÄ‚îÄ /css/
    ‚îî‚îÄ‚îÄ app.css             # Stili unificati (dark mode, responsive)
```

### Backend (Google Apps Script)

```
/gs/
‚îú‚îÄ‚îÄ magazzino.gs        # API CRUD ricambi (batchAddRicambi, updateRicambio, deleteRicambio)
‚îú‚îÄ‚îÄ riparazioni.gs      # API CRUD riparazioni + gestione clienti normalizzata
‚îî‚îÄ‚îÄ cartellini.gs       # [Futuro] Generazione PDF cartellini riparazione
```

**Endpoints principali:**
- `getRicambi` - Lista completa magazzino
- `getRicambio` - Singolo ricambio per codice
- `batchAddRicambi` - Inserimento multiplo (transazione atomica)
- `getRiparazioni` - Lista completa riparazioni (ordinate anno+progressivo decrescente)
- `getNextNumero` - Prossimo numero progressivo (lightweight endpoint)
- `getClienti` - Lista clienti per autocomplete
- `updateRiparazione` - Modifica riparazione esistente + **gestione automatica data completamento**
- `getLastUpdate` - Timestamp ultima modifica (cella M1)
- **`pollPrinter`** - Endpoint ottimizzato per T4 (v1.5.2):
  - Parametro: `ts` (timestamp client)
  - Se `ts >= M1`: ritorna `{ changed: false, ts: currentTs }`
  - Se `ts < M1`: ritorna `{ changed: true, ts: currentTs, riparazione: {...} }` con ultima scheda
  - Singola chiamata HTTP invece di due (getLastUpdate + getRiparazioni)

**Schema Google Sheets Riparazioni:**
- Colonna A-H: Numero, Data Consegna, Cliente, Indirizzo, Telefono, DDT, Attrezzi (JSON), Completato
- **Colonna I: Data Completamento** (auto-compilata dal backend)
  - Salvata automaticamente quando stato passa da "In corso" ‚Üí "Completato" (GMT+1)
  - Svuotata se torna da "Completato" ‚Üí "In corso"
  - Formato: YYYY-MM-DD (ISO)
  - Schede completate pre-implementazione: campo vuoto (gestito gracefully dal frontend)

### CI/CD (GitHub Actions)

**Workflow Magazzino:** `.github/workflows/update-csv.yml`
- Trigger: webhook da Cloudflare Worker
- Azione: scarica Google Sheets ‚Üí genera `magazzino.csv` ‚Üí commit ‚Üí deploy
- Throttle: max 1 esecuzione ogni 10 minuti (evita rate limiting)

**Workflow Statistiche:** `.github/workflows/update-statistics.yml`
- Trigger: cron daily 18:30 UTC (19:30 GMT+1) + workflow_dispatch manuale
- Azione: scarica CSV riparazioni ‚Üí esegue `js/generate-statistics.js` ‚Üí genera `js/statistiche.json` ‚Üí commit ‚Üí deploy
- Permessi: `contents: write` (necessario per push automatico)
- Trigger manuale: chiamata API GitHub con token PAT (offuscato split in frontend)

---

## üîë Componente Critica: CacheManager

**File:** `/js/cache-manager.js`

Singleton che gestisce cache localStorage con timestamp validation.

**API:**
```javascript
// Recupera dati se cache valida (altrimenti null)
const data = cacheManager.get('magazzino');

// Salva dati con timestamp corrente
cacheManager.set('magazzino', ricambiArray);

// Invalida cache specifica
cacheManager.invalidate('magazzino');

// Debug: stato di tutte le cache
console.log(cacheManager.getStats());
```

**Durate cache configurate:**
- `riparazioni`: 15 minuti (sessioni lavoro)
- `clienti`: 10 minuti (dati stabili)
- `magazzino`: 10 minuti (bilanciamento tra performance e freshness)

**Pattern implementato:**
1. Controlla cache localStorage all'avvio pagina
2. Se valida ‚Üí render istantaneo (0.1s)
3. Background update silenzioso (network-first)
4. Se scaduta/assente ‚Üí fetch API (2-3s)

---

## üì± Use Cases Principali

### UC1: Ricerca Ricambio Rapida

**Attore:** Tecnico in officina con tablet

**Flusso:**
1. Apre `/html/magazzino` (caricamento <0.1s se cache valida)
2. Digita codice parziale usando tastiera touch (es: "12345")
3. Risultati istantanei mentre digita (filter client-side su DATA array)
4. Tocca riga risultato ‚Üí dettaglio con scaffale
5. Swipe da sinistra ‚Üí torna alla ricerca

**Variante - Ricerca per scaffale:**
1. Digita "A01" ‚Üí mostra tutti i pezzi dello scaffale A01
2. Swipe orizzontale destro/sinistro ‚Üí naviga scaffali A01 ‚Üí A02 ‚Üí A03...

**Variante - Aggiornamento manuale:**
1. Dalla cima della pagina, swipe down (pull-to-refresh)
2. Appare indicatore blu "‚Üì Trascina per aggiornare"
3. Rilascia ‚Üí "‚ü≥ Aggiornamento in corso... (Xs)"
4. Polling automatico ogni 10s fino a CSV aggiornato (max 3 min)
5. "‚úì Aggiornato!" ‚Üí dati freschi visibili immediatamente

**Performance target:** <0.1s dall'input al risultato (no API call)

---

### UC6: Consultazione Statistiche

**Attore:** Amministratore monitora andamento riparazioni

**Flusso:**
1. Apre `/html/statistiche` da menu private
2. Visualizza 5 sezioni:
   - **Recap attuale:** totale in corso + top 3 pi√π vecchie (o oltre 90gg se presenti), numeri cliccabili ‚Üí dettaglio riparazione
   - **Recap settimanale:** sempre visibile
     - Sabato dopo 17:30 o domenica: "Questa settimana (date)"
     - Luned√¨-sabato prima 17:30: "Settimana scorsa (date)"
     - Media inseriti: dal 27 ottobre 2025, media completati: dal 12 gennaio 2026
     - Se perc tra -0.5% e +0.5% ‚Üí "perfettamente nella media"
     - Se perc null (dati insufficienti) ‚Üí "media non ancora calcolabile"
   - **Tempi riparazione:** controlli 30/90/tutto giorni
     - Filtra per data completamento (anche se inserite prima del periodo)
     - Media giorni, record velocit√†/lentezza, percentuali entro 14/30/60 giorni
     - Solo schede con data completamento popolata
   - **Grafico delta giornaliero:** bilancio (completate - aggiunte), dal 7 gennaio 2026
     - Controlli: 7/30/90/tutto giorni
     - Linea zero evidenziata, punti verdi (positivo) o rossi (negativo)
     - Solo giorni con attivit√† (no chiusure/domeniche)
   - **Grafici mensili:** riparazioni aggiunte/completate per mese, multi-anno con toggle, colori fissi per anno
3. Click "Aggiorna statistiche" ‚Üí trigger manuale GitHub Action via API (token offuscato split)
4. Integrazione iOS Shortcuts: campo `testoNotifica` in JSON per automazioni

**Sistema automatico:**
- GitHub Action daily 19:30 GMT+1, scarica CSV riparazioni, genera `js/statistiche.json`
- Parser CSV custom (gestione virgolette per campi JSON Attrezzi)
- Permessi workflow: `contents: write`

**Metriche:**
- Recap attuale: totale in corso, oltre 90gg, top 3 pi√π vecchie, testoNotifica per iOS
- Recap settimanale: inserite/completate vs media 6 mesi (date storiche separate)
- Tempi: array completo `{numero, cliente, dataCompletamento, giorni}` per filtraggio frontend
- Delta giornaliero: array `{data, aggiunte, completate, delta}` per ogni giorno con attivit√†
- Grafici mensili: count per mese/anno

---

### UC7: Inserimento Batch Ricambi

**Attore:** Amministratore aggiorna magazzino da fattura fornitore

**Flusso:**
1. Apre `/html/magazzino-nuovo`
2. Inserisce codice, descrizione, scaffale ‚Üí "Aggiungi alla coda"
3. Validazione duplicati real-time (check cache locale)
4. Ripete per 10-20 ricambi ‚Üí tutti in coda (lista visibile)
5. "Salva tutto" ‚Üí **batch insert** singola chiamata API
6. Toast verde "‚úì 20 ricambi salvati con successo!"
7. **Cache locale aggiornata immediatamente** con nuovi ricambi
8. GitHub Actions triggera workflow (aggiornamento CSV in background)

**Risultato:**
- Ritorna a `/html/magazzino` ‚Üí nuovi ricambi SUBITO visibili (da cache locale)
- Dopo ~2 min workflow GitHub completa ‚Üí CSV aggiornato per altri utenti

**Performance target:**
- Inserimento 20 ricambi: ~2 minuti totali (vs 10 min con insert singoli)
- Visibilit√† immediata: 0.1s (vs 2-3s attesa CSV prima di FASE 3)

---

### UC2: Nuova Riparazione Cliente

**Attore:** Receptionist riceve attrezzo da cliente

**Flusso:**
1. Apre `/html/riparazioni-nuovo`
2. Numero progressivo mostrato immediatamente (es: "25/0042")
3. Seleziona data consegna (default: oggi)
4. Inizia a digitare nome cliente ‚Üí **autocomplete** (cache 10 min, attivo da 2 caratteri)
   - Se cliente esistente ‚Üí auto-compila telefono
   - Se nuovo cliente ‚Üí inserisce telefono manualmente
5. Campo indirizzo ‚Üí **autocomplete paesi** (attivo gi√† dal primo carattere o al focus)
   - Mostra lista paesi unici dalla colonna "Indirizzo" del foglio Clienti
   - Facilita inserimento nuovi clienti con selezione rapida paese
6. Aggiunge attrezzo: marca, dotazione, note
7. Pu√≤ aggiungere pi√π attrezzi (es: "Trapano Makita" + "Smerigliatrice Bosch")
8. "Conferma" ‚Üí popup riepilogo
9. "Salva" ‚Üí API Google Sheets
10. **Cache riparazioni + clienti invalidata** (prossimo accesso ricarica dati freschi)
11. Reload pagina ‚Üí pronta per prossima scheda

**Performance target:** <1s dall'apertura pagina al form compilabile

---

### UC3: Consultazione Archivio Riparazioni

**Attore:** Tecnico cerca riparazione cliente per aggiornamento stato

**Flusso:**
1. Apre `/html/riparazioni-archivio` (caricamento <0.1s se cache valida)
2. **UI compatta con sticky header:**
   - Titolo "Archivio Riparazioni" + controlli filtri rimangono fissi in scroll
   - Solo righe tabella scorrono (ottimizzato per liste lunghe)
3. **Filtri stato compatti (riga 1):**
   - Barra ricerca cliente (ellipsis su overflow)
   - üî¥ (nn) - In corso | üü¢ (nn) - Completate
   - Multi-selezione: nessuno/uno/entrambi = mostra tutto
   - Contatori dinamici aggiornati in tempo reale
4. **Filtro date (riga 2):**
   - Default: dalla pi√π vecchia non completata a oggi
   - Input date auto-formattate (desktop: GG/MM/AAAA, mobile: GG/MM/AA)
   - Pulsante toggle "Tutte in corso" / "Tutte":
     - Click 1: "Tutte" (colori invertiti), forbice 15/10/2025 ‚Üí oggi
     - Click 2: "Tutte in corso" (normale), torna a default
     - Modifica manuale date ‚Üí spegne pulsante se attivo
   - Desktop: bottone largo 180px+0.5rem, mobile: 150px+0.5rem
5. **Tabella a 5 colonne:**
   - Desktop: Numero (15%) | Data ins. (15%) | Data com. (15%) | Cliente (40%) | Stato (15%)
   - Mobile: Num. (18%) | Ins. (14.5%) | Com. (14.5%) | Cliente (40%) | Stato (13%, emoji üî¥üü¢)
   - Data completamento mostra "-" se scheda non completata
6. Tocca riga ‚Üí `/html/riparazioni-dettaglio?numero=25/0042`
7. Visualizza dettaglio completo (cliente, telefono, attrezzi, stato, data completamento)
8. Navigazione prev/next istantanea (usa cache in memoria, no reload)
9. "Modifica scheda" ‚Üí form pre-compilato
10. Cambia stato ‚Üí data completamento salvata automaticamente (backend GMT+1)
11. Dati aggiornati localmente (no API call)
12. Burger menu ‚ò∞ ‚Üí torna ad archivio

**UX Ottimizzazioni:**
- Desktop: padding-top 2rem, mobile: safe-area-inset-top
- Spacing controlli: gap 0.5rem tra righe
- Bottoni filtro: 90px desktop, 75px mobile (larghezza fissa)
- Margini laterali mobile: 6px (massimizza spazio)

**Performance target:**
- Prima apertura: 2-3s (cache scaduta)
- Aperture successive (<15 min): 0.1s
- Navigazione prev/next: 0s (no reload, ordinamento corretto anno/numero decrescente)
- Filtri real-time: <0.05s

**Dettaglio Riparazione - UX Mobile/Desktop:**

**Layout Campi:**
- Desktop:
  - Riga 1: Cliente (flex:1) | Data consegna (17%, label "Data consegna")
  - Riga 2: Indirizzo (flex:1) | Telefono (20%) | DDT (15%) | Stato/Data com. (17%)
- Mobile:
  - Riga 1: Cliente (flex:1, ellipsis) | Data consegna (25%, label "Data cons.")
  - Riga 2: Indirizzo (flex:1, ellipsis) | Telefono (29%)
  - Riga 3: DDT (9%) | Stato/Data com. (25%)

**Logica Stato/Data Completamento:**
- Se presente Data Completamento ‚Üí label "Stato" diventa "Data com." + data formattata
- Se assente ‚Üí label "Stato" + badge colorato (üî¥ In corso / üü¢ Completato)

**Attrezzi:**
- Desktop: griglia 2 colonne, ultimo elemento dispari occupa tutta larghezza
- Mobile: 1 colonna

**Pulsanti Fixed Bottom:**
- Due pulsanti affiancati sopra: "Completa scheda" | "Modifica scheda"
  - Desktop: testo completo
  - Mobile: "Completa" | "Modifica"
- Tre pulsanti navigazione sotto: ‚Üê | ‚ò∞ | ‚Üí
- Padding inferiore: 2rem desktop, 0.5rem+safe-area mobile
- Pulsante "Completa scheda" visibile solo se riparazione non completata

**Popup Completamento:**
- Campo unico: Data completamento (default oggi, modificabile)
- API: `action=completaRiparazione`
- Aggiorna stato + data localmente senza reload

---

### UC4: Modifica Ricambio Esistente

**Attore:** Amministratore corregge scaffale errato

**Flusso:**
1. Cerca ricambio in `/html/magazzino`
2. Tocca risultato ‚Üí `/html/magazzino-dettaglio?codice=12345-1`
3. "Modifica" ‚Üí form con dati pre-compilati
4. Cambia scaffale da "A01" a "B05"
5. "Conferma" ‚Üí popup riepilogo ‚Üí "Salva"
6. API updateRicambio
7. **Cache magazzino invalidata** (prossimo accesso ricarica CSV aggiornato)
8. Torna a magazzino

**Alternative:**
- "Elimina ricambio" ‚Üí conferma ‚Üí rimuove riga da Google Sheets definitivamente

---

## ‚ö° Ottimizzazioni Implementate

### FASE 1: Riduzione Chiamate API
- Endpoint `getNextNumero` lightweight (50 bytes vs 100KB payload)
- Cache-first per riparazioni-archivio
- Tempo apertura form nuova riparazione: 2.5s ‚Üí 0.2s

### FASE 2: Cache Unificata
- CacheManager centralizzato (elimina 150 righe codice duplicato)
- Invalidazione automatica dopo modifiche
- Consistenza dati garantita tra pagine diverse

### FASE 3: Magazzino Cache-First (CRITICO)
- Pattern cache-first per magazzino (allineato a riparazioni)
- Durate cache strategiche (10 min per magazzino)
- **Aggiornamento locale cache dopo batch insert** (fix bug visibilit√†)
- Throttle GitHub Actions: 10 minuti (background)
- **Pull-to-refresh intelligente**:
  - Bypassa throttle (triggera sempre workflow)
  - Polling automatico ogni 10s per verificare aggiornamento CSV
  - Feedback visivo con timer
  - Timeout 3 minuti

**Impatto misurato:**
- Riapertura magazzino dopo 2 min: 2-3s ‚Üí 0.1s (-95%)
- Batch insert + verifica: dati visibili subito (era broken)
- Sessione 30 min (10 aperture): 25s ‚Üí 3.4s (-86%)
- Pull-to-refresh: aggiornamento garantito in ~2 min (tempo workflow)

---

## üîß Service Worker Cache Strategies

**File:** `/sw.js`

**Strategie per risorsa:**

| Risorsa | Strategia | Rationale |
|---------|-----------|-----------|
| `/magazzino.csv` | network-first | Dati freschi prioritari, fallback cache se offline |
| `/html/*.html` | network-first | Aggiornamenti codice immediati |
| `/css/app.css`, `/js/*.js` | network-first | Aggiornamenti codice immediati |
| `/icons/*.png` | cache-first | Icone statiche, performance |
| Navigazioni | network ‚Üí cache ‚Üí shell fallback | Resilienza offline |

**Versione cache attuale:** `em-maranzan-v46`

**Note:**
- Bump versione cache quando modifichi CSS/JS per forzare invalidazione
- CSS e JS usano cache busting con query parameters (?v=X) in HTML
- Service Worker si auto-aggiorna in background (non serve hard refresh utente)
- Hard refresh (Cmd+Shift+R) per debug durante sviluppo

---

## üö® Problemi Comuni e Soluzioni

### Problema: "Modifiche JS/CSS non visibili dopo deploy"
**Causa:** Service Worker serve vecchia versione JS/CSS da cache
**Soluzione:**
1. Bump `CACHE_NAME` in `sw.js` (es: v25 ‚Üí v26)
2. Bump query parameter in HTML:
   - CSS: `<link href="/css/app.css?v=24">` (es: v23 ‚Üí v24)
   - JS: `<script src="/js/magazzino.js?v=23">` (es: v22 ‚Üí v23)
3. Aggiorna PRECACHE_URLS nel SW con nuova versione CSS
4. Commit e push
5. La PWA si auto-aggiorna e ricarica automaticamente alla prossima apertura

**Nota:** Il sistema ora include auto-reload del SW, non serve hard refresh manuale. CSS e JS **devono avere** cache busting per funzionare correttamente su iOS PWA.

### Problema: "GitHub workflow run failed"
**Causa:** Troppi trigger ravvicinati (rate limiting)
**Soluzione:** Throttle 10 minuti implementato - max 6 trigger/ora

### Problema: "Modifiche su Google Sheets non visibili subito"
**Causa:** Cache valida (10 min) + workflow GitHub in corso (~2 min)
**Soluzione:**
1. Swipe down dalla cima (pull-to-refresh)
2. Attendi indicatore "‚ü≥ Aggiornamento in corso... (Xs)"
3. Quando appare "‚úì Aggiornato!" ‚Üí dati freschi visibili
4. Se timeout (3 min) ‚Üí riprova o aspetta che workflow completi

### Problema: "Errore scheda non trovata dopo modifica"
**Causa:** Codice prova a ricaricare da API prima che Google Sheets aggiorni
**Soluzione:** Fix implementato - dati aggiornati localmente senza API reload

### Problema: "CSV serve HTML invece di dati"
**Causa:** Fetch usa path relativo da `/html/` ‚Üí cerca `/html/magazzino.csv`
**Soluzione:** Usa sempre path assoluto `/magazzino.csv`

---

### Pattern Salvataggio Dati
```javascript
// ‚úÖ GIUSTO: Aggiorna cache locale dopo modifica
const result = await apiSave(data);
if (result.success) {
  // Aggiorna cache locale con dati nuovi
  const cached = cacheManager.get('tipo') || [];
  const updated = [...cached, newItem].sort(...);
  cacheManager.set('tipo', updated);
}

// ‚ùå SBAGLIATO: Invalida cache (prossimo accesso lento)
cacheManager.invalidate('tipo');
```

### Aggiungere Nuova Pagina Gestionale
1. Crea `/html/nuova-pagina.html`
2. Crea `/js/nuova-pagina.js`
3. Includi `<script src="/js/cache-manager.js"></script>` prima del tuo JS
4. Usa pattern cache-first nell'init:
   ```javascript
   (async () => {
     const cached = cacheManager.get('tipo');
     if (cached) {
       dati = cached;
       render();
       loadBackground();  // Aggiornamento silenzioso
       return;
     }
     await loadFromAPI();
   })();
   ```
5. Aggiungi link in `/private.html`
6. Aggiungi swipe gesture per tornare a `/private.html`

### Testing Checklist
- [ ] Prima apertura giornata ‚Üí 2-3s (OK, cache vuota)
- [ ] Riapertura <10 min ‚Üí 0.1s istantaneo
- [ ] Riapertura >10 min ‚Üí ricarica CSV aggiornato
- [ ] Pull-to-refresh ‚Üí swipe down ‚Üí ricarica forzato
- [ ] Modifica dati ‚Üí salva ‚Üí cache aggiornata
- [ ] Torna alla lista ‚Üí modifiche visibili subito
- [ ] Console F12 ‚Üí nessun errore rosso
- [ ] Offline ‚Üí funziona con ultimi dati cache
- [ ] Mobile ‚Üí touch responsive, no zoom necessario



---

## üîí Sicurezza e Backup

### SEO e Indicizzazione

**Pagina pubblica:**
- `index.html` - Homepage pubblica indicizzabile

**Pagine protette (non indicizzate):**
- `private.html` - Hub gestionale
- `/html/*.html` - Tutte le pagine del gestionale

Tutte le pagine gestionali includono:
```html
<meta name="robots" content="noindex, nofollow, noarchive">
<meta name="googlebot" content="noindex, nofollow, noarchive">
```

**Nota:** Solo index.html deve essere indicizzabile. Mai rimuovere meta robots dalle altre pagine.

---

### Permessi Google Sheets

**Fogli Database:**
- **Magazzino:** ID `1wFamrwzFNNz5iHenqVpdAHb5Dhvv5xYx5XPimjax9As`
- **Riparazioni:** ID `122xQdmQb02UH6evZE382t0s6oRDIoiOhF5cYAAmEvY0`

**Configurazione consigliata:**
- Condivisione: "Chiunque con il link pu√≤ visualizzare" (sola lettura)
- Editor: Solo account Google autorizzati (inviti specifici)
- Apps Script: "Esegui come: Me (proprietario)" per funzionamento API

**Link in private.html:**
- I link ai fogli Google sono visibili solo a utenti autorizzati
- Se non autorizzato, appare "Richiedi accesso"
- Non compromettono la sicurezza se fogli in sola lettura

**Fix Critico riparazioni.gs:**
- Usare `SpreadsheetApp.openById(SPREADSHEET_ID)` invece di `getActiveSpreadsheet()`
- Garantisce funzionamento API anche con foglio in sola lettura
- Gi√† implementato in `/gs/riparazioni.gs` (riga 2, 60, 131, 165, 206, 242, 291, 331)

---

### Backup Automatico

**Sistema:** Google Apps Script con trigger settimanale

**File:** `/gs/backup-automation.gs`

**Configurazione:**
- **Frequenza:** Domenica 03:00-04:00
- **Storico:** Mantiene ultimi 4 backup (1 mese)
- **Destinazione:** Cartella Drive "Backup EM Maranzan" (non linkata pubblicamente)
- **Sicurezza:** Elimina SOLO file che iniziano con "Magazzino_" o "Riparazioni_" (altri file al sicuro)

**Setup:**
1. Crea cartella Drive "Backup EM Maranzan"
2. Apri cartella e copia ID dalla URL (es: `drive.google.com/drive/folders/XXXXXX` ‚Üí copia `XXXXXX`)
3. Inserisci ID in `BACKUP_FOLDER_ID` (riga 14 del file backup-automation.gs)
4. Crea progetto Apps Script standalone (https://script.google.com ‚Üí Nuovo progetto)
5. Copia codice da `backup-automation.gs` nell'editor
6. Test manuale: esegui funzione `testBackup()` (autorizza permessi alla prima esecuzione)
7. Aggiungi trigger settimanale (‚è∞ icona Trigger ‚Üí Domenica 3-4 AM)

**Utility:**
- `testBackup()` - Test manuale immediato
- `listBackups()` - Mostra tutti i backup esistenti
- `cleanOldBackups()` - Pulizia automatica backup vecchi

**Ripristino da backup:**
1. Vai su Drive ‚Üí Backup EM Maranzan
2. Trova backup desiderato (formato: `Magazzino_YYYY-MM-DD_HHmm`)
3. Tasto destro ‚Üí Crea copia
4. Rinomina e sposta nella posizione principale
5. Aggiorna ID nel codice se necessario

---

## üìû Contatti Tecnici

**Deploy URL:** https://elettromeccanica-maranzan.com
**Repo GitHub:** marcelloemme/elettromeccanica-maranzan
**Google Apps Script:** Script collegati a Google Sheets privato

---

## üìö File Importanti da Non Toccare

- `/magazzino.csv` - Generato automaticamente da GitHub Actions (non editare manualmente)
- `/.github/workflows/update-csv.yml` - CI/CD workflow (modifica solo se sai cosa fai)
- `/manifest.webmanifest` - PWA config (cambiare `start_url` richiede reinstall app)
- `/gs/*.gs` - Google Apps Script (deploy manuale su Google)

---

## üñ®Ô∏è Progetto Hardware: Stampante Termica T4

### Panoramica
Sistema hardware autonomo per stampare automaticamente le schede riparazione su carta termica.

**Componenti:**
- **LilyGo T4 v1.3** (ESP32 4MB Flash + 8MB PSRAM) con display 2.4" ILI9341
- **Stampante CSN-A2 TTL** (termica, formato scontrino)
- **MicroSD card** per storage locale database
- **WiFi** per sincronizzazione con Google Sheets

### Specifiche Hardware

**LilyGo T4 v1.3:**
- MCU: ESP32 (NON S3!) - Dual-core Xtensa LX6
- Flash: 4MB
- PSRAM: 8MB
- Display: ILI9341 240x320 (2.4")
  - SCLK ‚Üí IO18, RST ‚Üí IO05, CS ‚Üí IO27
  - BL ‚Üí IO04, RS ‚Üí IO32, SDI ‚Üí IO23, SDO ‚Üí IO12
- MicroSD Reader:
  - MISO ‚Üí IO02, SCK ‚Üí IO14, MOSI ‚Üí IO15, CS ‚Üí IO13
- Pulsanti programmabili: IO38 (sx), IO37 (centro), IO39 (dx)
- Chip seriale: CH9102F QFN24

**CSN-A2 TTL:**
- Connettore alimentazione: 9V+ / GND
- Connettore seriale: GND / RXD / TXD
- Collegamento T4:
  - Stampante RXD ‚Üí T4 GPIO33 (TX software)
  - Stampante TXD ‚Üí T4 GPIO35 (RX software)
  - GND comune
- Alimentazione T4: 5V tramite regolatore esterno da 9V stampante

**Note:** GPIO33/35 usati per evitare conflitti con porta seriale hardware (debugging).

---

### Architettura Software

**Toolchain:** PlatformIO + ESP32 Arduino Framework

**Flusso operativo:**

```
[Avvio dispositivo]
    ‚Üì
[Connetti WiFi FASTWEB-RNHDU3]
    ‚Üì
[Scarica CSV da Google Sheets in RAM]
    ‚Üì
[Calcola MD5 del CSV scaricato]
    ‚Üì
[Confronta MD5 con ultima versione su SD]
    ‚Üì
    ‚îú‚îÄ SE DIVERSO ‚Üí Aggiorna file su SD + salva nuova MD5 in RAM
    ‚îî‚îÄ SE UGUALE ‚Üí Usa versione esistente su SD
    ‚Üì
[Carica UI su display: ultime 50 schede]
    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  [Loop principale ogni 60 secondi]      ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  - Scarica CSV aggiornato                ‚îÇ
‚îÇ  - Confronta MD5                         ‚îÇ
‚îÇ  - SE cambio ‚Üí aggiorna SD + UI          ‚îÇ
‚îÇ  - SE nuove schede ‚Üí stampa automatica   ‚îÇ
‚îÇ  - Aggiorna print_history.txt            ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  [Parallelo: gestione UI pulsanti]      ‚îÇ
‚îÇ  - Frecce su/gi√π ‚Üí selezione scheda     ‚îÇ
‚îÇ  - Pulsante centro ‚Üí stampa manuale      ‚îÇ
‚îÇ  - Timeout 30s ‚Üí spegni display          ‚îÇ
‚îÇ  - Qualsiasi pulsante ‚Üí riaccendi        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### Logica Print History

**File SD:** `/print_history.txt`

**Formato:**
```
26/0021
26/0020
26/0019
...
```

**Regole:**
1. **Primo avvio dopo power-off**:
   - Crea/sostituisci `print_history.txt`
   - Marca TUTTE le schede come gi√† stampate (anche nuove)
   - NON stampa mai nulla al primo avvio

2. **Check periodici ogni 60s (dispositivo acceso)**:
   - Scarica CSV aggiornato e confronta MD5
   - SE MD5 diverso ‚Üí aggiorna CSV su SD
   - **SEMPRE confronta CSV con print_history**
   - SE scheda presente in CSV ma NON in print_history ‚Üí √® nuova ‚Üí stampa automatica + aggiorna history
   - SE scheda modificata (numero esistente) ‚Üí NON stampare (solo modifiche dati)

3. **Stampa manuale (pulsante utente)**:
   - Permette ristampare qualsiasi scheda (anche gi√† stampata)
   - NON modifica print_history (cos√¨ resta "gi√† stampata" per check auto)

**Razionale:**
- Evita "vomito di carta" se dispositivo spento per giorni/settimane
- Solo nuove schede create MENTRE il dispositivo √® acceso vengono stampate automaticamente
- Modifiche a schede esistenti (es: cambio telefono, aggiunta note) NON triggerano stampa
- L'MD5 rileva cambiamenti al file, ma solo il confronto print_history identifica nuove schede

---

### Interfaccia Display

**Layout UI:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 26/0021 Friul Servizi       ‚îÇ ‚Üê Evidenziata (bianco su nero)
‚îÇ 26/0020 Manias Daniele      ‚îÇ
‚îÇ 26/0019 Dazzan              ‚îÇ
‚îÇ 26/0018 ...                 ‚îÇ
‚îÇ 26/0017 ...                 ‚îÇ
‚îÇ ...                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   ‚Üì   ‚îÇ  Stampa  ‚îÇ    ‚Üë    ‚îÇ ‚Üê Pulsanti fissi bottom
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   IO38    IO37      IO39
```

**Comportamento:**
- **Schede mostrate:** Ultime 50 dal CSV (ordinate per numero decrescente)
- **Selezione:** Prima scheda evidenziata di default
- **Frecce:** Navigazione su/gi√π con paginazione automatica
- **Stampa:** Pulsante centro stampa scheda selezionata
- **Power saving:** Display off dopo 30s inattivit√†, riattiva con qualsiasi pulsante

**Font e dimensioni:**
- Font leggibile (TBD in implementazione)
- Massimo numero righe possibili in 240x320 (lasciando 40-50px per pulsanti bottom)
- Test per determinare dimensione ottimale (es: 6-8 righe visibili)

---

### Dati e Sincronizzazione

**CSV Source:**
```
https://docs.google.com/spreadsheets/d/e/2PACX-1vTLu_kAJJ7pIFcbxUC8082z7jG1EP-lFgoJmNVae-0w0_uZWABdJ8yWXxPViw8bqge1TOWXeUmFZyrp/pub?gid=0&single=true&output=csv
```

**Formato CSV (riparazioni):**
```
Numero,Data Consegna,Cliente,Telefono,Indirizzo,Attrezzo,Marca,Dotazione,DDT,Macchina,Matricola,Note,Operatore,Completato
26/0021,2025-01-08,Friul Servizi,0434123456,Pordenone,...
```

**WiFi Credentials:**
- SSID: `FASTWEB-RNHDU3`
- Password: `C9FLCJDDRY`

**Fallback Offline:**
- Se WiFi assente/errore connessione ‚Üí usa ultima versione SD
- Retry automatico ogni 60s

---

### Storage e Performance

**RAM (8MB PSRAM):**
- CSV completo caricato in RAM per performance
- MD5 hash corrente salvato in variabile globale
- Array schede (struct) per UI

**SD Card:**
- `/riparazioni.csv` - Database locale (backup, usato se WiFi offline)
- `/print_history.txt` - Schede gi√† stampate (lista numeri)

**Ottimizzazioni:**
- CSV processato in RAM (parsing una volta all'avvio)
- Scritture SD solo quando MD5 cambia (minimizza wear)
- MD5 calcolato in streaming (no doppia allocazione memoria)

---

### Librerie PlatformIO Richieste

**Essenziali:**
```ini
[env:esp32dev]
platform = espressif32
board = esp32dev
framework = arduino

lib_deps =
  bodmer/TFT_eSPI @ ^2.5.43          # Display ILI9341
  https://github.com/adafruit/Adafruit-Thermal-Printer-Library.git  # CSN-A2
  bblanchon/ArduinoJson @ ^7.2.0     # Parsing CSV
```

**Nota:** La libreria Adafruit va installata da GitHub (non disponibile su registry PlatformIO per macOS ARM).


**Built-in ESP32:**
- WiFi.h (connessione rete)
- SD.h / SD_MMC.h (storage locale)
- MD5Builder.h (hashing per confronto file)
- SoftwareSerial.h (comunicazione stampante via GPIO33/35)

**Configurazione TFT_eSPI:**
- File `User_Setup.h` custom per pin mapping ILI9341
- Verificare pin corretti: CS=27, RS=32, RST=5, etc.

---

### Path Progetto Hardware

```
/hardware/t4-printer/          # Root progetto PlatformIO
‚îú‚îÄ‚îÄ platformio.ini             # Config board + librerie
‚îú‚îÄ‚îÄ src/main.cpp               # Firmware principale
‚îú‚îÄ‚îÄ include/User_Setup.h       # Config TFT_eSPI (pin mapping T4)
‚îî‚îÄ‚îÄ README.md                  # Documentazione hardware
```

**Comandi utili:**
```bash
cd hardware/t4-printer
pio run                        # Compila
pio run -t upload              # Upload su T4
pio device monitor             # Serial Monitor (115200 baud)
```

---

### Roadmap Implementazione

#### ‚úÖ Fase 0-5: Setup, Hardware, Connettivit√†, Parsing, UI, Stampa (COMPLETATE)
- [x] Progetto PlatformIO con librerie (TFT_eSPI, ArduinoJson)
- [x] Display ILI9341, pulsanti, SD card, stampante CSN-A2 (19200 baud)
- [x] WiFi + download CSV + parsing JSON attrezzi
- [x] UI con header, lista 10 schede, scroll, pulsanti grafici

#### ‚úÖ Fase 6: Print History (COMPLETATA)
- [x] File `/print_history.txt` su SD (max 200 schede)
- [x] All'avvio: reset history con schede correnti dal CSV (non stampa nulla)
- [x] Traccia schede stampate per evitare duplicati

#### ‚úÖ Fase 7: Auto-Print con Trigger Push (COMPLETATA + OTTIMIZZATA v1.5.2)
- [x] **Nuovo:** Action `pollPrinter` - singola chiamata che verifica timestamp E restituisce scheda
- [x] **Nuovo:** Polling 1.5s (5s in modalit√† debug SER), timeout HTTP 8s
- [x] **Nuovo:** Stampa automatica entro ~8s dall'inserimento (era ~15-20s)
- [x] Endpoint `getLastUpdate` in `gs/riparazioni.gs` (legge timestamp da cella M1)
- [x] `createRiparazione()` aggiorna M1 con `Date.now()` dopo inserimento
- [x] Task FreeRTOS su core 0 per polling parallelo
- [x] Verifica CSV contenga nuova scheda prima di dichiarare sync (10 retry √ó 10s)

#### ‚úÖ Fase 8: Power Management (COMPLETATA)
- [x] Display sleep dopo 30s senza input pulsanti (backlight OFF)
- [x] Wake-up con qualsiasi pulsante (primo tocco solo risveglia)
- [x] Auto-wake quando stampa automatica in corso

#### ‚úÖ Fase 9: WiFi Multi-Rete + Captive Portal (COMPLETATA)
- [x] File `/wifi_config.txt` su SD con max 5 reti (formato: `SSID|password`)
- [x] FIFO: la 6a rete cancella la 1a (meno recente)
- [x] All'avvio: connessione a rotazione su tutte le reti salvate
- [x] Retry WiFi ogni 60s a rotazione se disconnesso
- [x] Pulsante centrale all'avvio ‚Üí modalit√† AP "EM Maranzan" (no password)
- [x] Captive portal mobile-friendly per configurare nuove reti
- [x] Messaggi stato: "WiFi disconnesso" (rosso), "Errore connessione" (arancione), "Connesso" (verde)

#### ‚úÖ Fase 10: Stampa Manuale Scheda Storica (COMPLETATA)
- [x] Long press OK (2s) dalla lista ‚Üí modalit√† inserimento numero
- [x] UI: numero grande centrato con cursore su cifra corrente
- [x] Frecce ‚Üë/‚Üì: cambiano cifra (0-9 wrap), OK: avanza cursore
- [x] Ricerca nel CSV locale su SD (funziona offline, tutte le schede storiche)
- [x] Timeout 20s inattivit√† ‚Üí torna alla lista
- [x] Long press OK (2s) per annullare
- [x] Errore scheda non trovata ‚Üí cursore torna a prima cifra

#### ‚úÖ Fase 11: OTA Updates + Boot Menu (COMPLETATA)
- [x] **Nuovo v1.5.0:** Menu boot 2 secondi con 3 pulsanti:
  - SX (IO38): OTA Update
  - CENTRO (IO37): Captive Portal WiFi
  - DX (IO39): Modalit√† SER (debug, polling 5s)
- [x] Download firmware da GitHub raw (`/hardware/EM_Maranzan_printer.bin`)
- [x] Progress bar su display durante download
- [x] Riavvio automatico dopo aggiornamento completato
- [x] Fallback: se WiFi assente o file non trovato ‚Üí avvio normale

#### üü° Fase 12: Deployment
- [ ] Test stress e ottimizzazioni finali
- [ ] Installazione in officina

---

### Note Implementazione

**Gestione Memoria:**
- ESP32 ha ~520KB SRAM + 8MB PSRAM (usare PSRAM per CSV grande)
- Usare `ps_malloc()` per allocare in PSRAM invece che SRAM
- CSV 150 righe √ó ~200 byte = ~30KB (gestibile, ma crescer√†)

**Formato Stampa Carta Termica:**
- Larghezza carta: 58mm (CSN-A2 standard)
- Caratteri per riga: ~32 (font default Adafruit)

**Layout Etichetta Compatta (IMPLEMENTATO):**
```
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 26/0077 (1/2) ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚Üê riga 31 char nera, testo bianco centrato
Lenarduzzi Bruno                ‚Üê font normale (max 32 char, troncato)
21.01.26 - 339/7808759 - Sesto  ‚Üê font condensato (ESC M 1)
Levigatrice rupes - batteria    ‚Üê font normale (max 32 char, marca troncata con ".")
Non funziona                    ‚Üê font condensato
```
- Riga 1: numero con padding spazi, **31 caratteri** (compensa byte spurio da sleep)
- Riga 2: cliente (max 32 char, troncato se pi√π lungo)
- Riga 3: data - telefono - indirizzo (font condensato, omessi se vuoti)
- Riga 4: attrezzo - dotazione (max 32 char, marca troncata con "." se necessario)
- Riga 5: note (font condensato, opzionale)
- Spaziature: 1mm tra riga 1-2 e tra riga 3-4, solo line feed altrove
- Multi-attrezzo: etichette separate con (1/2), pausa 6s
- **Densit√† stampa:** ESC 7 con n1=11, n2=120, n3=40 (ottimizzata per carta adesiva)

**WiFi Multi-Rete:**
- Max 5 reti salvate su SD (`/wifi_config.txt`)
- Connessione a rotazione all'avvio e in caso di errore
- Retry ogni 60s (task FreeRTOS su core 0)
- Captive portal: AP "EM Maranzan" + pagina web configurazione

**Modalit√† Inserimento Manuale:**
- Accesso: long press OK (2s) dalla lista
- Cerca nel CSV locale su SD (non richiede WiFi)
- Timeout 20s inattivit√† ‚Üí torna alla lista
- Uscita: long press OK (2s) o stampa completata

**Debug:**
- Serial monitor a 115200 baud per log
- Log dettagliato ricerca scheda su SD

---

### File Storage su SD

| File | Descrizione |
|------|-------------|
| `/riparazioni.csv` | CSV completo scaricato da Google Sheets |
| `/print_history.txt` | Numeri schede gi√† stampate (max 200, FIFO) |
| `/wifi_config.txt` | Reti WiFi salvate (max 5, formato `SSID\|password`) |

### File Firmware su GitHub

| File | Descrizione |
|------|-------------|
| `/hardware/EM_Maranzan_printer.bin` | Firmware compilato per OTA updates |

---

### Firmware Attuale: v1.5.2

**File:** `hardware/t4-printer/src/main.cpp`

**Librerie:** TFT_eSPI, ArduinoJson, WebServer, DNSServer, SD, WiFi, HTTPClient, Update

**Changelog recente:**

**v1.5.2** - Ottimizzazione stampa veloce (~8s dall'inserimento)
- Nuova action GS `pollPrinter`: singola chiamata HTTP che controlla timestamp E restituisce scheda
- Polling ridotto a 1.5s (5s in modalit√† debug SER)
- Timeout HTTP ridotto a 8s
- Eliminata doppia chiamata API (era: getLastUpdate + getRiparazioni)

**v1.5.1** - Fix barra nera sempre 31 caratteri
- Problema: byte spurio anche alla prima stampa dopo boot (non solo da sleep)
- Soluzione: usare sempre 31 caratteri per la barra nera (buffer per byte spurio)

**v1.5.0** - Menu boot + fix stampa da sleep
- Menu boot 2 secondi con 3 pulsanti: OTA (sx), WIFI (centro), SER (dx)
- Modalit√† SER: polling 5s invece di 1.5s, utile per debug
- Flag `printFromSleep` per stampa manuale da sleep

**v1.4.9** - Densit√† stampa per carta adesiva
- Comando ESC 7 con parametri ottimizzati: n1=11 (heating dots max), n2=120, n3=40
- Stampa pi√π scura e definita su carta termica adesiva

**v1.4.8** - Text wrapping cliente
- Nome cliente troncato a max 32 caratteri
- Polling ridotto da 5s a 2.5s

**v1.4.7** - Text wrapping attrezzo-dotazione
- Riga "Attrezzo - Dotazione" max 32 char, marca troncata con "."
- Centramento testo corretto con 31 caratteri

**v1.4.6** - Fix barra nera pragmatico
- Usare 31 caratteri invece di 32 quando si stampa da sleep
- Compensa byte spurio che appare dopo wake-up display

**v1.4.5** - Tentativo fix barra nera (delay backlight)
- Aggiunto delay dopo accensione backlight
- Non risolutivo (problema persisteva)

**v1.4.2-1.4.4** - Fix fast print
- Verifica che CSV contenga nuova scheda prima di dichiarare "synchronized"
- 10 tentativi ogni 10s per verificare aggiornamento CSV
- Fix campo "Data consegna" (lowercase 'c')

**v1.4.1** - Fix ordinamento schede
- Sorting per anno+progressivo (26/0079 > 25/0133)
- Prima ordinava solo per progressivo (bug)

---

### OTA (Over-The-Air) Updates

**URL Firmware GitHub:**
```
https://raw.githubusercontent.com/marcelloemme/elettromeccanica-maranzan/main/hardware/EM_Maranzan_printer.bin
```

**Come aggiornare il firmware:**
1. Compila il nuovo firmware: `pio run`
2. Copia `.pio/build/esp32dev/firmware.bin` in `/hardware/EM_Maranzan_printer.bin`
3. Commit e push su GitHub
4. Sul dispositivo: tieni premuto **pulsante SU** all'accensione
5. Il dispositivo scarica e installa automaticamente il nuovo firmware

**Comportamento:**
- Connette WiFi ‚Üí scarica `.bin` da GitHub ‚Üí progress bar ‚Üí riavvio
- Se WiFi assente: mostra errore, avvio normale dopo 3s
- Se file non trovato su GitHub: mostra errore, avvio normale dopo 3s
- Se download fallisce: mostra errore HTTP, avvio normale dopo 3s

**Note:**
- Il file `.bin` deve essere pushato su branch `main`
- Dimensione max firmware: ~1.3MB (flash disponibile)
- L'update sovrascrive la partizione app corrente

---

## üìö File Importanti da Non Toccare

- `/magazzino.csv` - Generato automaticamente da GitHub Actions (non editare manualmente)
- `/.github/workflows/update-csv.yml` - CI/CD workflow (modifica solo se sai cosa fai)
- `/manifest.webmanifest` - PWA config (cambiare `start_url` richiede reinstall app)
- `/gs/*.gs` - Google Apps Script (deploy manuale su Google)

---